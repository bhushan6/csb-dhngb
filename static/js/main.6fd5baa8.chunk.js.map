{"version":3,"sources":["Components/StateStore/store.js","Components/HtmlOverlay/HtmlOverlay.js","Components/Lights/Lights.js","Components/Player/Firstpersonprespective.js","Assets/Stalls/type1-centerDraco.glb","Components/Hall/Stalls/Type1_center.js","Assets/Stalls/type1-cornerDraco.glb","Components/Hall/Stalls/Type1_corner.js","Assets/Stalls/type2-centerDraco.glb","Components/Hall/Stalls/Type2_center.js","Assets/Stalls/type2-cornerDraco.glb","Components/Hall/Stalls/Type2_corner.js","Assets/Stalls/type3-centerDraco.glb","Assets/Stalls/ReceptionTable/ReceptionDraco.glb","Components/Hall/Stalls/ReceptionTable/ReceptionDraco.js","Components/Hall/Stalls/Type3_center.js","Assets/Stalls/type3-cornerDraco.glb","Components/Hall/Stalls/Type3_corner.js","Assets/Walls/LeftWall/LeftWall.glb","Assets/Walls/LeftWall/LightMap.jpg","Assets/Walls/LeftWall/Side_Walls_AO.jpg","Assets/Walls/LeftWall/Side_Walls_emisionmaop.jpg","Components/Hall/Walls/LeftWall.js","Assets/Walls/Rightwall/RightWallDraco.glb","Components/Hall/Walls/RightWall.js","Assets/Walls/FrontWall/FrontWall.glb","Components/Hall/Walls/FrontWall.js","Assets/Ground/Grey Noise.jpg","Assets/Ground/Grey Noise Normal.jpg","Assets/Stalls/ReceptionTable/Reception2.glb","Components/Hall/Stalls/ReceptionTable/Reception2.js","Assets/Stalls/Broucher/Broucher.glb","Components/Hall/Stalls/Broucher/Broucher.js","Assets/Stalls/VCTable/VCTable.glb","Components/Hall/Stalls/VCTable/VCTable.js","Assets/Stalls/KTv/KTv.glb","Components/Hall/Stalls/KTv/KTv.js","Assets/Stalls/Display/Display.glb","Components/Hall/Stalls/Display/Display.js","Components/Hall/Stalls/Logo/BannerInstance.js","Assets/Stalls/Standee/Standee.glb","Components/Hall/Stalls/Standee/Standee.js","App.js","index.js"],"names":["useStore","create","set","playerTeleport","position","undefined","teleportState","teleportTo","newPosition","state","touchController","movementState","forward","backward","left","right","movement","key","buttonsActive","breakMovement","setTimeout","HtmlOverlay","controllerState","pressed","e","target","id","leave","onPointerDown","onPointerUp","className","Lights","THREE","Math","PI","intensity","color","groundColor","extend","InstancedUniformsMesh","useGLTF","preload","model","leftWall","App","useState","stallData","setStallData","types","setTypes","getStallData","a","fetch","response","json","data","stall","useEffect","rows","forEach","index","length","coloumn","stall_type","push","shadows","gl","alpha","antialias","camera","fov","near","far","onCreated","physicallyCorrectLights","outputEncoding","dpr","min","window","devicePixelRatio","OrbitControls","Stats","rootElement","document","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.6fd5baa8.chunk.js","sourcesContent":["import create from \"zustand\";\r\n\r\nconst useStore = create(set => ({\r\n    playerTeleport : {\r\n        position : undefined,\r\n        teleportState : false,\r\n        teleportTo : (newPosition) => set(state => (state.playerTeleport.position = newPosition))\r\n    },\r\n\r\n    touchController : {\r\n        movementState : {\r\n            forward : false,\r\n            backward : false,\r\n            left : false,\r\n            right : false\r\n        },\r\n        movement : (key) => set(state => {\r\n            state.touchController.movementState[key] = true\r\n            state.touchController.buttonsActive = true\r\n        }),\r\n        breakMovement : (key) => set(state => {\r\n            state.touchController.movementState[key] = false\r\n            setTimeout(() => {state.touchController.buttonsActive = false}, 200)\r\n        }),\r\n        buttonsActive : false\r\n    }\r\n  }))\r\n\r\n\r\n  export default useStore","import React from 'react'\r\nimport { FaArrowAltCircleUp, FaArrowAltCircleLeft, FaArrowAltCircleDown, FaArrowAltCircleRight} from 'react-icons/fa';\r\nimport useStore from \"../StateStore/store.js\"\r\n\r\nconst HtmlOverlay = () => {\r\n\r\n    // const [upPressed, setIsPressed] = React.useState(false)\r\n\r\n    const controllerState = useStore(state => state.touchController)\r\n\r\n    const pressed = (e) => {\r\n        // setIsPressed(true)\r\n        if(e.target.id !== \"\"){\r\n            controllerState.movement(e.target.id)\r\n        }\r\n    }\r\n\r\n    const leave = e => {\r\n        // setIsPressed(false)\r\n        if(e.target.id !== \"\"){\r\n            controllerState.breakMovement(e.target.id)\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div id=\"html-overlay\">\r\n            <div id=\"controls\">\r\n\r\n                <div\r\n                    onPointerDown = {e => pressed(e)}\r\n                    onPointerUp = {e => leave(e)}\r\n                    id = \"left\"\r\n                    className = \"btn\"\r\n                >\r\n                     <FaArrowAltCircleLeft className = \"icon\"/>\r\n                </div>\r\n                <div className=\"center\">\r\n                    <div\r\n                        onPointerDown = {e => pressed(e)}\r\n                        onPointerUp = {e => leave(e)}\r\n                        id = \"forward\"\r\n                        className = \"btn\"\r\n                    >\r\n                        <FaArrowAltCircleUp className = \"icon\"/>\r\n                    </div>\r\n                    <div\r\n                        onPointerDown = {e => pressed(e)}\r\n                        onPointerUp = {e => leave(e)}\r\n                        id = \"backward\"\r\n                        className = \"btn\"\r\n                    >\r\n                        <FaArrowAltCircleDown className = \"icon\"/>\r\n                    </div>\r\n                </div>\r\n                <div\r\n                    onPointerDown = {e => pressed(e)}\r\n                    onPointerUp = {e => leave(e)}\r\n                    id = \"right\"\r\n                    className = \"btn\"\r\n                >\r\n                     <FaArrowAltCircleRight className = \"icon\"/>\r\n                </div>\r\n            </div>\r\n            <p id = \"instruction\">To move around</p>\r\n        </div>\r\n         \r\n        \r\n    )\r\n}\r\n\r\nexport default HtmlOverlay\r\n","import React from 'react'\r\n\r\nconst Lights = () => {\r\n\r\n    \r\n    return (\r\n       <>\r\n        <ambientLight intensity = {2}/>\r\n        <hemisphereLight intensity={1} color = \"#ffffff\"  groundColor=\"#323231\" position= {[0, 50, 0]}/>\r\n        <directionalLight intensity= {6} position ={[15, 0, -15]}/>\r\n        <directionalLight intensity= {6} position ={[-15, 0, 15]}/>\r\n        <directionalLight intensity= {6} position ={[0, 15, 0]}/>\r\n       </>\r\n    )\r\n}\r\n\r\nexport default Lights\r\n","import React, { useEffect, useRef, useState } from \"react\"\r\nimport * as THREE from \"three\"\r\nimport {useSphere } from \"@react-three/cannon\"\r\nimport { useThree, useFrame } from \"@react-three/fiber\"\r\nimport useStore from \"../StateStore/store\"\r\n\r\nconst SPEED = 50;\r\nconst keys = { ArrowUp: \"forward\", ArrowDown: \"backward\", ArrowLeft: \"left\", ArrowRight: \"right\"}\r\nconst moveFieldByKey = (key) => keys[key]\r\nconst direction = new THREE.Vector3()\r\nconst frontVector = new THREE.Vector3()\r\nconst sideVector = new THREE.Vector3()\r\nconst euler = new THREE.Euler(0, 0, 0, \"YXZ\")\r\nconst minPolarAngle = 0;\r\nconst maxPolarAngle = Math.PI;\r\nconst _PI_2 = Math.PI/2;\r\n\r\n\r\n\r\nconst usePlayerControls = () => {\r\n  const [movement, setMovement] = useState({ forward: false, backward: false, left: false, right: false})\r\n\r\n  const {camera} = useThree()\r\n  \r\n  const handleMouseMove = (e) => {\r\n    if(e.buttons === 1){\r\n      const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\r\n      const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\r\n\r\n      euler.setFromQuaternion( camera.quaternion );\r\n\r\n\t\t\teuler.y -= movementX * 0.002;\r\n\t\t\teuler.x -= movementY * 0.002;\r\n\r\n\t\t\teuler.x = Math.max( _PI_2 - maxPolarAngle, Math.min( _PI_2 - minPolarAngle, euler.x ) );\r\n\r\n\t\t\tcamera.quaternion.setFromEuler( euler );\r\n    }\r\n  }\r\n \r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {setMovement((m) => ({ ...m, [moveFieldByKey(e.code)]: true }))}\r\n    const handleKeyUp = (e) => setMovement((m) => ({ ...m, [moveFieldByKey(e.code)]: false }))\r\n    document.addEventListener(\"keydown\", handleKeyDown)\r\n    document.addEventListener(\"keyup\", handleKeyUp)\r\n    document.addEventListener(\"pointermove\", handleMouseMove)\r\n\r\n    return () => {\r\n      document.removeEventListener(\"keydown\", handleKeyDown)\r\n      document.removeEventListener(\"keyup\", handleKeyUp)\r\n      document.removeEventListener(\"pointermove\", handleMouseMove)\r\n    }\r\n  }, [])\r\n  return movement\r\n}\r\n\r\nconst Firstpersonprespective = (props) => {\r\n  const [ref, api] = useSphere(() => ({ mass: 1, type: \"Dynamic\", position : [0, 5, 0],...props }))\r\n  \r\n  const teleportation = useStore(state => state.playerTeleport)\r\n  let controllerState = useStore(state => state.touchController)\r\n\r\n    const teleport = () => {\r\n      if(teleportation.position){\r\n        let p = ref.current.position.lerp(teleportation.position, 0.1)\r\n        api.position.set(p.x, p.y, p.z)\r\n      }\r\n    }\r\n\r\n    let {forward, backward, left, right} = usePlayerControls()\r\n\r\n    const { camera } = useThree()\r\n \r\n    useEffect(() => {camera.rotation.set(0, 0, 0)}, [])\r\n\r\n    const velocity = useRef([0, 0, 0])\r\n\r\n    useEffect(() => void api.velocity.subscribe((v) => (velocity.current = v)), [])\r\n    useFrame(() => {\r\n        if(teleportation.teleportState === true){\r\n          teleport()\r\n        }\r\n\r\n        if(controllerState.buttonsActive === true){\r\n          forward = controllerState.movementState.forward\r\n          backward = controllerState.movementState.backward\r\n          left = controllerState.movementState.left\r\n          right = controllerState.movementState.right\r\n        }\r\n        \r\n        camera.position.set(ref.current.position.x, 5, ref.current.position.z)\r\n        frontVector.set(0, 0, Number(backward) - Number(forward))\r\n        sideVector.set(Number(left) - Number(right), 0, 0)\r\n        direction.subVectors(frontVector, sideVector).normalize().multiplyScalar(SPEED).applyEuler(camera.rotation)\r\n        api.velocity.set(direction.x, velocity.current[1], direction.z)\r\n    })\r\n\r\n    return <mesh ref={ref} />\r\n}\r\n\r\nexport default Firstpersonprespective\r\n","export default __webpack_public_path__ + \"static/media/type1-centerDraco.b6c7a8a8.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from '../../../Assets/Stalls/type1-centerDraco.glb'\n\nextend({ InstancedUniformsMesh })\n\nexport default function Model({positionData, position, color}) {\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n  const ref7 = useRef()\n  const ref8 = useRef()\n  const ref9 = useRef()\n  const ref10 = useRef()\n  const ref11 = useRef()\n  const ref12 = useRef()\n\n  // console.log(color)\n\n  const refArr = [ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, ref10, ref11, ref12]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n\n    positionData.map((b, index) => {\n        dummy.position.set(b[0] *34 , b[2]*30, -0.15*30)\n        dummy.rotation.set(0, 0, Math.sign(-b[2])*Math.PI/2)\n        dummy.updateMatrix()         \n\n        refArr.map(r => {\n          r.current.setMatrixAt(index, dummy.matrix)\n        })\n\n\n        threeColor.set(color[index])\n        \n        ref12.current.setUniformAt('diffuse', index, threeColor)\n        ref7.current.setUniformAt('diffuse', index, threeColor)\n        \n    \n    })\n    refArr.map(r => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n}, [positionData])\n\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null} position={position}>\n      <group position={[0, 0, 0]} rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh\n          ref={ref1}\n          args={[nodes.Mesh004.geometry, null, positionData.length ]} \n          material={materials['Base_AO1.001']} />\n        <instancedMesh \n          ref={ref2}\n          args = {[nodes.Mesh004_1.geometry , null, positionData.length]}\n          material={materials.Base_AO2} />\n        <group position={[0, 0, -0.28]}>\n          <instancedMesh \n            ref={ref3}\n            args = {[ nodes.Mesh005.geometry, null, positionData.length]}\n            material={materials.ciling_light1} />\n          <instancedMesh \n            ref={ref4}\n            args = {[ nodes.Mesh005_1.geometry, null, positionData.length]}\n            material={materials.ciling_light_emision1} />\n        </group>\n        <instancedMesh\n          ref={ref5}\n          args={[ nodes.Mesh006.geometry ,null, positionData.length]}\n          material={materials.hanging_light_mat} />\n        <instancedMesh\n          ref={ref6}\n          args={[ nodes.Mesh006_1.geometry,null, positionData.length]}\n          material={materials.hanging_Emissive_ligts} />\n        <instancedUniformsMesh \n          ref={ref7}\n          args={[nodes.Mesh007.geometry ,null, positionData.length]}\n          material={materials['Theme_color_glow.001']} />\n        <instancedMesh\n          ref={ref8}\n          args={[ nodes.Mesh007_1.geometry,null, positionData.length]}\n          material={materials['floor.001']} />\n        <instancedMesh\n          ref={ref9}\n          args={[nodes.Mesh007_2.geometry ,null, positionData.length]}\n          material={materials.White_color} />\n        <instancedMesh\n          ref={ref10}\n          args={[ nodes.Mesh007_3.geometry,null, positionData.length]}\n          material={materials.White_color_2} />\n        <instancedMesh\n          ref={ref11}\n          args={[nodes.Mesh007_4.geometry ,null, positionData.length]}\n          material={materials['Gry_color.001']} />\n        <instancedUniformsMesh \n          ref={ref12}\n          args={[ nodes.Mesh007_5.geometry,null, positionData.length]}\n          material={materials['Theme_color.001']} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/type1-cornerDraco.700b4537.glb\";","\nimport React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from '../../../Assets/Stalls/type1-cornerDraco.glb'\n\nextend({ InstancedUniformsMesh })\n\n\nexport default function Model({positionData, color}) {\n  const group = useRef()\n  // const ref1 = useRef()\n  // const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n  const ref7 = useRef()\n  const ref8 = useRef()\n  const ref9 = useRef()\n  const ref10 = useRef()\n  const ref11 = useRef()\n  const ref12 = useRef()\n  const ref13 = useRef()\n\n\n  const refArr = [ref3, ref4, ref5, ref6, ref7, ref8, ref9, ref10, ref11, ref12, ref13]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n\n    positionData.map((b, index) => {\n        dummy.position.set(b[0] *34 , b[2]*30, -0.15*30)\n        const r = b[2] > 0 ? 1 :  0\n        dummy.rotation.set(0, 0, r*Math.PI)\n        dummy.updateMatrix()         \n\n        refArr.map(r => {\n          r.current.setMatrixAt(index, dummy.matrix)\n        })\n\n\n        threeColor.set(color[index])\n        \n        ref12.current.setUniformAt('diffuse', index, threeColor)\n        ref8.current.setUniformAt('diffuse', index, threeColor)\n        \n    \n    })\n    refArr.map(r => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n  }, [positionData])\n\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        {/* <group position={[154.13, -0.68, 0]} rotation={[0, 0, -Math.PI / 3]}>\n          <instancedMesh\n            // position={[154.13, -0.68, 0]}\n            // rotation={[0, -Math.PI/2, 0]}\n            ref={ref1}\n            args={[ nodes.Mesh.geometry, null, positionData.length]}\n            material={materials.Base_AO1} />\n          <instancedMesh\n            // position={[154.13, -0.68, 0]}\n            // rotation={[0, Math.PI/2, 0]}\n            ref={ref2}\n            args={[ nodes.Mesh_1.geometry, null, positionData.length]}\n            material={materials.BaseAO_2} />\n        </group> */}\n        <instancedMesh\n          ref={ref3}\n          args={[ nodes.Mesh003.geometry, null, positionData.length]}\n          material={materials.light_metal} />\n        <instancedMesh\n          ref={ref4}\n          args={[ nodes.Mesh003_1.geometry, null, positionData.length]}\n          material={materials.Lights_emisson} />\n        <instancedMesh\n          ref={ref5}\n          args={[ nodes.Mesh002.geometry, null, positionData.length]}\n          material={materials.hanging_light_matt} />\n        <instancedMesh\n          ref={ref6}\n          args={[ nodes.Mesh002_1.geometry, null, positionData.length]}\n          material={materials.hanging_light_emission} />\n        <instancedMesh\n          ref={ref7}\n          args={[ nodes.Mesh001.geometry, null, positionData.length]}\n          material={materials.Metal} />\n        <instancedUniformsMesh \n          ref={ref8}\n          args={[ nodes.Mesh001_1.geometry, null, positionData.length]}\n          material={materials.Theme_color} />\n        <instancedMesh\n          ref={ref9}\n          args={[ nodes.Mesh001_2.geometry, null, positionData.length]}\n          material={materials.white_color} />\n        <instancedMesh\n          ref={ref10}\n          args={[ nodes.Mesh001_3.geometry, null, positionData.length]}\n          material={materials.Gry_color} />\n        <instancedMesh\n          ref={ref11}\n          args={[ nodes.Mesh001_4.geometry, null, positionData.length]}\n          material={materials.white_color_glow} />\n        <instancedUniformsMesh \n          ref={ref12}\n          args={[ nodes.Mesh001_5.geometry, null, positionData.length]}\n          material={materials.Theme_color_glow} />\n        <instancedMesh\n          ref={ref13}\n          args={[ nodes.Mesh001_6.geometry, null, positionData.length]}\n          material={materials.floor} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/type2-centerDraco.aaaf0ff7.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from '../../../Assets/Stalls/type2-centerDraco.glb'\n\nextend({ InstancedUniformsMesh })\n\nexport default function Model({positionData, color}) {\n\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n  const ref7 = useRef()\n  const ref8 = useRef()\n  const ref9 = useRef()\n  const ref10 = useRef()\n  const ref11 = useRef()\n  const ref12 = useRef()\n  const ref13 = useRef()\n \n  const refArr = [ref3, ref4, ref5, ref6, ref7, ref8, ref9, ref10, ref11, ref12, ref13]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n\n    positionData.map((b, index) => {\n        dummy.position.set(b[0] *34 , b[2]*30, -0.15*30)\n        const r = b[2] > 0 ? 1 : 0\n        dummy.rotation.set(0, 0, r*Math.PI)\n        dummy.updateMatrix()         \n\n        refArr.map(r => {\n          r.current.setMatrixAt(index, dummy.matrix)\n        })\n\n\n        threeColor.set(color[index])\n        \n        ref9.current.setUniformAt('diffuse', index, threeColor)\n        ref1.current.setUniformAt('diffuse', index, threeColor)\n        \n    \n    })\n    refArr.map(r => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n  }, [positionData])\n\n\n  \n\n  return (\n    <group ref={group} dispose={null} scale={[3,3,3]}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <group position={[53.7, -64.37, 0]}>\n          <instancedUniformsMesh\n            ref={ref1}\n            args={[nodes.Mesh010.geometry ,null, positionData.length]}\n            material={materials['Theme_color_glow.002']} />\n          <instancedMesh\n            ref={ref2}\n            args={[ nodes.Mesh010_1.geometry,null, positionData.length]}\n            material={materials.AO} />\n        </group>\n        <instancedMesh\n          ref={ref3}\n          args={[ nodes.Mesh009.geometry,null, positionData.length]}\n          material={materials.ligts_Matt} />\n        <instancedMesh\n          ref={ref4}\n          args={[ nodes.Mesh009_1.geometry,null, positionData.length]}\n          material={materials.Light_Emision} />\n        <instancedMesh\n          ref={ref5}\n          args={[ nodes.Mesh008.geometry,null, positionData.length]}\n          material={materials.white_color_2} />\n        <instancedMesh\n          ref={ref6}\n          args={[ nodes.Mesh008_1.geometry,null, positionData.length]}\n          material={materials['white_color.001']} />\n        <instancedMesh\n          ref={ref7}\n          args={[ nodes.Mesh008_2.geometry,null, positionData.length]}\n          material={materials.Base_Matt} />\n        <instancedMesh\n          ref={ref8}\n          args={[ nodes.Mesh008_3.geometry,null, positionData.length]}\n          material={materials['white_color_glow.001']} />\n        <instancedUniformsMesh\n          ref={ref9}\n          args={[ nodes.Mesh008_4.geometry,null, positionData.length]}\n          material={materials['Theme_color.002']} />\n        <instancedMesh\n          ref={ref10}\n          args={[ nodes.Mesh008_5.geometry,null, positionData.length]}\n          material={materials.Roof} />\n        <instancedMesh\n          ref={ref11}\n          args={[ nodes.Mesh008_6.geometry,null, positionData.length]}\n          material={materials.Gray_Matt} />\n        <instancedMesh\n         ref={ref12}\n         args={[ nodes.Mesh008_7.geometry,null, positionData.length]}\n         material={materials.glow} />\n        <instancedMesh\n          ref={ref13}\n          args={[ nodes.Mesh008_8.geometry,null, positionData.length]}\n          material={materials.Stand_Metal} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/type2-cornerDraco.55c842d8.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from '../../../Assets/Stalls/type2-cornerDraco.glb'\n\nextend({ InstancedUniformsMesh })\n\nexport default function Model({positionData, color}) {\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n  const ref7 = useRef()\n  const ref8 = useRef()\n  const ref9 = useRef()\n \n  const refArr = [ref3, ref4, ref5, ref6, ref7, ref8, ref9]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n\n    positionData.map((b, index) => {\n        dummy.position.set(b[0] *34 , b[2]*30, -0.15*30)\n        const r = b[2] > 0 ? 1 : 0\n        dummy.rotation.set(0, 0, r*Math.PI)\n        dummy.updateMatrix()         \n\n        refArr.map(r => {\n          r.current.setMatrixAt(index, dummy.matrix)\n        })\n\n\n        threeColor.set(color[index])\n        \n        ref4.current.setUniformAt('diffuse', index, threeColor)\n        ref6.current.setUniformAt('diffuse', index, threeColor)\n        \n    \n    })\n    refArr.map(r => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n  }, [positionData])\n\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh \n          ref={ref8}\n          args={[ nodes.Mesh016.geometry,null, positionData.length]}\n          material={materials['Base_AO1.002']} />\n        <instancedMesh \n          ref={ref9}\n          args={[ nodes.Mesh016_1.geometry,null, positionData.length]}\n          material={materials.Theme_color_glow_AO} />\n        <instancedMesh \n          ref={ref1}\n          args={[ nodes.Mesh015.geometry,null, positionData.length]}\n          material={materials.light_metal_matt} />\n        <instancedMesh \n          ref={ref2}\n          args={[ nodes.Mesh015_1.geometry,null, positionData.length]}\n          material={materials['Light_Emision.002']} />\n        <instancedMesh \n          ref={ref3}\n          args={[ nodes.Mesh014.geometry,null, positionData.length]}\n          material={materials['white_color.003']} />\n        <instancedUniformsMesh \n          ref={ref4}\n          args={[ nodes.Mesh014_1.geometry,null, positionData.length]}\n          material={materials['Theme_color_glow.004']} />\n        <instancedMesh \n          ref={ref5}\n          args={[ nodes.Mesh014_2.geometry,null, positionData.length]}\n          material={materials.Floor} />\n        <instancedUniformsMesh \n          ref={ref6}\n          args={[ nodes.Mesh014_3.geometry,null, positionData.length]}\n          material={materials['Theme_color.004']} />\n        <instancedMesh \n          ref={ref7}\n          args={[ nodes.Mesh014_4.geometry,null, positionData.length]}\n          material={materials['white_color_glow.003']} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/type3-centerDraco.a415ebce.glb\";","export default __webpack_public_path__ + \"static/media/ReceptionDraco.89e65baa.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from \"../../../../Assets/Stalls/ReceptionTable/ReceptionDraco.glb\"\n\nextend({ InstancedUniformsMesh })\n\n// let instanceSize = 0\n\n// const rpos = [\n//   [-57.5, 5, -80],\n//   [-7.5, 5, 80],\n//   [-7.5, 5, -80],\n//   [42.5, 5, 80],\n//   [-175, 5, -80],\n//   [-112.5, 5, 80],\n//   [-112.5, 5, -80],\n//   [-57.5, 5, 80],\n//   [42.5, 5, -80],\n//   [105, 5, 80],\n//   [-175, 5, 80],\n//   [105, 5, -80],\n//   [175, 5, 80]\n// ]\n\nconst rTable = {\n  \"type2-center\" : {x : -10, y : 14, z : 0},\n  \"type3-center\" : {x : 9, y : 15, z : 0},\n  \"type2-corner\" : {x : -11, y : 15, z : 0},\n  \"type1-center\" : {x : -7, y : 9, z : 20},\n  \"type1-corner\" : {x : -3, y : 9, z : 20},\n  \"type3-corner\" : {x : 14, y : 14, z : 20},\n}\n\nexport default function Model({data, instanceSize}) {\n  const stallData = {...data}\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n\n  const refArr = [ref1, ref2, ref3, ref4, ref5, ref6]\n\n  const { nodes, materials } = useGLTF(model)\n  delete stallData[\"type3-center\"]\n  delete stallData[\"type3-corner\"]\n  const dataArray = Object.values(stallData)\n  const typeArray = Object.keys(stallData)\n\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n    let j = 0\n    dataArray.forEach((ele, index) => {\n      const posArr = ele.pos\n      const colorArr = ele.color\n      const offset = rTable[typeArray[index]]\n          posArr.forEach((position, i) => {\n            dummy.position.set((position[0] + (offset.x*Math.sign(-position[2])))*34, (position[2] + (offset.y*Math.sign(-position[2])))*30, -(position[1]+offset.z))\n            const r = position[2] > 0 ? 1 : 0\n            dummy.rotation.set(0, 0, Math.PI*r)\n            dummy.updateMatrix()\n            refArr.forEach((r) => {\n              r.current.setMatrixAt(j, dummy.matrix)\n            })\n            threeColor.set(colorArr[i])\n            \n            ref2.current.setUniformAt('diffuse', j, threeColor)\n            ref5.current.setUniformAt('diffuse', j, threeColor)\n            j += 1\n          })\n    })\n\n    refArr.forEach((r) => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n\n  }, [data])\n\n\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh\n         ref={ref1}\n         args={[nodes.Base_AO.geometry, null, instanceSize]}\n         material={materials.Base_AO1} />\n        <group position={[0, 0, 0.02]}>\n          <instancedUniformsMesh\n           ref={ref2}\n           args={[nodes.Mesh.geometry, null, instanceSize]}\n           material={materials.Theme_color} />\n          <instancedMesh\n           ref={ref3}\n           args={[nodes.Mesh_1.geometry, null, instanceSize]}\n           material={materials.white_color} \n           />\n          <instancedMesh\n           ref={ref4}\n           args={[nodes.Mesh_2.geometry, null, instanceSize]}\n           material={materials.glass} />\n          <instancedUniformsMesh \n           ref={ref5}\n           args={[nodes.Mesh_3.geometry, null, instanceSize]}\n           material={materials.Theme_color_glow} />\n          <instancedMesh\n           ref={ref6}\n           args={[nodes.Mesh_4.geometry, null, instanceSize]}\n           material={materials.white_color_glow} />\n        </group>\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from '../../../Assets/Stalls/type3-centerDraco.glb'\n\nimport ReceptionDraco from \"./ReceptionTable/ReceptionDraco\"\n\nextend({ InstancedUniformsMesh })\n\nexport default function Model({positionData, color}) {\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n  const ref7 = useRef()\n  const ref8 = useRef()\n  const ref9 = useRef()\n  const ref10 = useRef()\n  const ref11 = useRef()\n  const ref12 = useRef()\n  const ref13 = useRef()\n \n  const refArr = [ref3, ref4, ref5, ref6, ref7, ref8, ref9, ref10, ref11, ref12, ref13]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n\n    positionData.map((b, index) => {\n        dummy.position.set(b[0] *34 , b[2]*34, -0.15*30)\n        let r = b[2] > 0 ? 1 : 0\n        dummy.rotation.set(0, 0, r*Math.PI)\n        dummy.updateMatrix()         \n\n        refArr.map(r => {\n          r.current.setMatrixAt(index, dummy.matrix)\n        })\n\n\n        threeColor.set(color[index])\n        \n        ref7.current.setUniformAt('diffuse', index, threeColor)\n        ref12.current.setUniformAt('diffuse', index, threeColor)\n        \n    \n    })\n    refArr.map(r => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n  }, [positionData])\n\n\n  return (\n    <>\n      <group ref={group} scale={[3,3,3]} >\n        <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n          <instancedMesh\n          ref={ref1}\n          args={[nodes.Mesh019.geometry ,null, positionData.length]}\n          material={materials['AO.002']} />\n          <instancedMesh\n          ref={ref2}\n          args={[ nodes.Mesh019_1.geometry,null, positionData.length]}\n          material={materials.color_AO} />\n          <instancedMesh\n          ref={ref3}\n          args={[ nodes.Mesh018.geometry,null, positionData.length]}\n          material={materials.ceiling_lights_matt} />\n          <instancedMesh\n          ref={ref4}\n          args={[ nodes.Mesh018_1.geometry,null, positionData.length]}\n          material={materials.ceiling_lights_emision} />\n          <instancedMesh\n          ref={ref5}\n          args={[ nodes.Mesh017.geometry,null, positionData.length]}\n          material={materials['hanging_light_matt.001']} />\n          <instancedMesh\n          ref={ref6}\n          args={[ nodes.Mesh017_1.geometry,null, positionData.length]}\n          material={materials.hanging_light_emision} />\n          <instancedUniformsMesh\n          ref={ref7}\n          args={[ nodes.Mesh020.geometry,null, positionData.length]}\n          material={materials['Theme_color.005']} />\n          <instancedMesh\n          ref={ref8}\n          args={[ nodes.Mesh020_1.geometry,null, positionData.length]}\n          material={materials.color} />\n          <instancedMesh\n          ref={ref9}\n          args={[ nodes.Mesh020_2.geometry,null, positionData.length]}\n          material={materials.Black_matt} />\n          <instancedMesh\n          ref={ref10}\n          args={[ nodes.Mesh020_3.geometry,null, positionData.length]}\n          material={materials['Gry_color.002']} />\n          <instancedMesh\n          ref={ref11}\n          args={[ nodes.Mesh020_4.geometry,null, positionData.length]}\n          material={materials['Floor.001']} />\n          <instancedUniformsMesh\n          ref={ref12}\n          args={[ nodes.Mesh020_5.geometry,null, positionData.length]}\n          material={materials['Theme_color_glow.005']} />\n          <instancedMesh\n          ref={ref13}\n          args={[ nodes.Mesh020_6.geometry,null, positionData.length]}\n          material={materials.LED} />\n        </group>\n        {/* <ReceptionDraco/> */}\n      </group>\n    </>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/type3-cornerDraco.1d6cb66c.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from '../../../Assets/Stalls/type3-cornerDraco.glb'\n\nextend({ InstancedUniformsMesh })\n\nexport default function Model({positionData, color}) {\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n  const ref7 = useRef()\n  const ref8 = useRef()\n  const ref9 = useRef()\n  const ref10 = useRef()\n  const ref11 = useRef()\n  const ref12 = useRef()\n \n  const refArr = [ref3, ref4, ref5, ref6, ref7, ref8, ref9, ref10, ref11, ref12]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n\n    positionData.map((b, index) => {\n        dummy.position.set(b[0] *34 , b[2]*30, -0.15*30)\n        const r = b[2] > 0 ? 1 : 0\n        dummy.rotation.set(0, 0, r*Math.PI)\n        dummy.updateMatrix()         \n\n        refArr.map(r => {\n          r.current.setMatrixAt(index, dummy.matrix)\n        })\n\n\n        threeColor.set(color[index])\n        \n        ref8.current.setUniformAt('diffuse', index, threeColor)\n        // ref12.current.setUniformAt('diffuse', index, threeColor)\n        \n    \n    })\n    refArr.map(r => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n  }, [positionData])\n\n\n  return (\n    <group ref={group} scale={[3,3,3]}  dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh\n         ref={ref1}\n         args={[ nodes.Mesh021.geometry, null, positionData.length]}\n         material={materials.Base_AO_2} />\n        <instancedMesh\n         ref={ref2}\n         args={[ nodes.Mesh021_1.geometry, null, positionData.length]}\n         material={materials['Base_AO1.003']} />\n        <instancedMesh\n         ref={ref3}\n         args={[ nodes.Mesh022.geometry, null, positionData.length]}\n         material={materials['ligts_Matt.002']} />\n        <instancedMesh\n         ref={ref4}\n         args={[ nodes.Mesh022_1.geometry, null, positionData.length]}\n         material={materials.emision_matt} />\n        <instancedMesh\n         ref={ref5}\n         args={[ nodes.Mesh023.geometry, null, positionData.length]}\n         material={materials['hanging_light_matt.002']} />\n        <instancedMesh\n         ref={ref6}\n         args={[ nodes.Mesh023_1.geometry, null, positionData.length]}\n         material={materials.Emision_matt2} />\n        <instancedMesh\n         ref={ref7}\n         args={[ nodes.Mesh024.geometry, null, positionData.length]}\n         material={materials.Gry_standee} />\n        <instancedUniformsMesh\n         ref={ref8}\n         args={[ nodes.Mesh024_1.geometry, null, positionData.length]}\n         material={materials.Theem_color} />\n        <instancedMesh\n         ref={ref9}\n         args={[ nodes.Mesh024_2.geometry, null, positionData.length]}\n         material={materials['white_color.004']} />\n        <instancedMesh\n         ref={ref10}\n         args={[ nodes.Mesh024_3.geometry, null, positionData.length]}\n         material={materials.gry} />\n        <instancedMesh\n         ref={ref11}\n         args={[ nodes.Mesh024_4.geometry, null, positionData.length]}\n         material={materials['floor.002']} />\n        <instancedMesh\n         ref={ref12}\n         args={[ nodes.Mesh024_5.geometry, null, positionData.length]}\n         material={materials.white_color_glow1} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/LeftWall.bbc8020b.glb\";","export default __webpack_public_path__ + \"static/media/LightMap.e3b8bece.jpg\";","export default __webpack_public_path__ + \"static/media/Side_Walls_AO.c42d3260.jpg\";","export default __webpack_public_path__ + \"static/media/Side_Walls_emisionmaop.1895acb6.jpg\";","import React, { useRef } from 'react'\r\nimport { useGLTF, useTexture } from '@react-three/drei'\r\nimport * as THREE from \"three\"\r\nimport leftWall from \"../../../Assets/Walls/LeftWall/LeftWall.glb\"\r\nimport light from \"../../../Assets/Walls/LeftWall/LightMap.jpg\"\r\nimport ao from \"../../../Assets/Walls/LeftWall/Side_Walls_AO.jpg\"\r\nimport emission from \"../../../Assets/Walls/LeftWall/Side_Walls_emisionmaop.jpg\"\r\n\r\nexport default function Model({size, position}) {\r\n  const group = useRef()\r\n  const ref1 = useRef()\r\n  const ref2 = useRef()\r\n  const ref3 = useRef()\r\n  const { nodes, materials } = useGLTF(leftWall)\r\n\r\n  const refArr = [ref1, ref2, ref3]\r\n\r\n  const [lightMap, aoMap, emissionMap] = useTexture([light, ao, emission])\r\n\r\n  lightMap.flipY = false\r\n  aoMap.flipY = false\r\n  lightMap.encoding = THREE.RGBFormat\r\n  aoMap.encoding = THREE.RGBFormat\r\n  emissionMap.encoding = THREE.RGBFormat\r\n\r\n  const m = React.useMemo(() => new THREE.MeshPhongMaterial({\r\n      aoMap : aoMap,\r\n      // aoMapIntensity : 3,\r\n      lightMap : lightMap,\r\n      // lightMapIntensity : 3,\r\n      emissiveMap : emissionMap,\r\n      emissiveIntensity : 15,\r\n      map: lightMap,\r\n      // side : THREE.DoubleSide,\r\n      color : \"rgb(180, 180 ,180)\"\r\n  }), [])\r\n\r\n  const m3 = React.useMemo(() => new THREE.MeshPhongMaterial({\r\n    aoMap : aoMap,\r\n    aoMapIntensity : 3,\r\n    lightMap : lightMap,\r\n    // lightMapIntensity : 3,\r\n    emissiveMap : emissionMap,\r\n    emissiveIntensity : 15,\r\n    map: lightMap,\r\n    // side : THREE.DoubleSide,\r\n    color : \"rgb(180, 180 ,180)\"\r\n}), [])\r\n\r\n  const m2 = React.useMemo(() => new THREE.MeshPhongMaterial({\r\n    aoMap : aoMap,\r\n    // aoMapIntensity : 3,\r\n    lightMap : lightMap,\r\n    // lightMapIntensity : 3,\r\n    color : \"rgb(95, 95, 95)\",\r\n    map: lightMap,\r\n    // side : THREE.DoubleSide\r\n}), [])\r\n\r\n    const dummy = React.useMemo(() => new THREE.Object3D(), [])\r\n\r\n  React.useLayoutEffect(() => {\r\n      const arraySize = Math.round(size/27) + 2\r\n      Array(arraySize).fill(null).map((b, index) => {\r\n          dummy.position.set(index*300 - (size*6), 0, 0)\r\n          dummy.updateMatrix()\r\n          refArr.map(r => {\r\n              r.current.setMatrixAt(index, dummy.matrix)\r\n            })\r\n      })\r\n\r\n      refArr.map(r => {\r\n          r.current.instanceMatrix.needsUpdate = true\r\n        })\r\n  }, [])\r\n\r\n\r\n  return (\r\n    <group ref={group} position={position} scale={[3,3,3]} dispose={null}>\r\n      <group position={[0, 0, 0]} rotation={[Math.PI / 2, 0, 0]} scale={[0.03, 0.03, 0.03]}>\r\n        <instancedMesh \r\n            ref={ref1}\r\n            args ={[nodes.Mesh001.geometry,null, Math.round(size/27)+2]}\r\n            material={m}/>\r\n        <instancedMesh \r\n            ref={ref2}\r\n            args ={[nodes.Mesh001_1.geometry,null, Math.round(size/27)+2]}\r\n            material={m3} />\r\n        <instancedMesh \r\n            ref={ref3}\r\n            args ={[nodes.Mesh001_2.geometry,null, Math.round(size/27)+2]}\r\n            material={m2}/>\r\n      </group>\r\n    </group>\r\n  )\r\n}\r\n\r\nuseGLTF.preload(leftWall)\r\n","export default __webpack_public_path__ + \"static/media/RightWallDraco.ca62b60b.glb\";","import React, { useRef } from \"react\";\nimport { useGLTF } from \"@react-three/drei\";\nimport * as THREE from \"three\";\nimport model from \"../../../Assets/Walls/Rightwall/RightWallDraco.glb\";\n\nexport default function Model({ size, position }) {\n  const group = useRef();\n  const ref1 = useRef();\n  const ref2 = useRef();\n  const { nodes, materials } = useGLTF(model);\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), []);\n\n  React.useLayoutEffect(() => {\n    const arraySize = Math.round(size / 27) + 2;\n    Array(arraySize)\n      .fill(null)\n      .map((a, index) => {\n        dummy.position.set(index * 305 - size * 6, 0, 0);\n        dummy.updateMatrix();\n        ref1.current.setMatrixAt(index, dummy.matrix);\n        ref2.current.setMatrixAt(index, dummy.matrix);\n      });\n    ref1.current.instanceMatrix.needsUpdate = true;\n    ref2.current.instanceMatrix.needsUpdate = true;\n  }, []);\n\n  return (\n    <group position={position} ref={group} scale={[9, 9, 9]} dispose={null}>\n      <group\n        position={[0, 0, 0]}\n        rotation={[Math.PI / 2, 0, 0]}\n        scale={[0.01, 0.01, 0.01]}\n      >\n        <instancedMesh\n          ref={ref1}\n          args={[nodes.Mesh002.geometry, null, Math.round(size / 27) + 2]}\n          material={materials[\"Wall.001\"]}\n        />\n        <instancedMesh\n          ref={ref2}\n          args={[nodes.Mesh002_1.geometry, null, Math.round(size / 27) + 2]}\n          material={materials[\"Light.001\"]}\n        />\n      </group>\n    </group>\n  );\n}\n\nuseGLTF.preload(model);\n","export default __webpack_public_path__ + \"static/media/FrontWall.ead950a7.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from 'three'\nimport model from \"../../../Assets/Walls/FrontWall/FrontWall.glb\"\n\nexport default function Model({ size }) {\n  const group = useRef()\n  const ref = useRef()\n  const { nodes, materials } = useGLTF(model)\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n\n  React.useLayoutEffect(() => {\n    const i = [-1, 1]\n    for (let index = 0; index < 2; index++) {\n      dummy.position.set(((size/2)+(size/15)) * 30 * i[index], 0, 0)\n      dummy.updateMatrix()\n      ref.current.setMatrixAt(index, dummy.matrix)\n    }\n    ref.current.instanceMatrix.needsUpdate = true\n  }, [size])\n\n  return (\n    <group ref={group} scale={[3, 9, 6]} dispose={null}>\n      <instancedMesh\n        ref={ref}\n        args={[nodes.front_Wall.geometry, null, 2]}\n        material={materials.Wall2}\n        position={[-0.41, -0.04, -15.75]}\n        rotation={[Math.PI / 2, 0, 0]}\n        scale={[0.01, 0.01, 0.01]}\n      />\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/Grey Noise.9708d7b4.jpg\";","export default __webpack_public_path__ + \"static/media/Grey Noise Normal.01faed7d.jpg\";","export default __webpack_public_path__ + \"static/media/Reception2.a8f9b458.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport model from \"../../../../Assets/Stalls/ReceptionTable/Reception2.glb\"\n\nconst rTable = {\n  \"type3-center\" : {x : 9, y : 14, z : 0},\n  \"type3-corner\" : {x : 14, y : 14, z : 20}\n}\n\nexport default function Model({data}) {\n  const stallData = {...data}\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n\n  const refArr = [ref1, ref2, ref3, ref4, ref5]\n\n  const { nodes, materials } = useGLTF(model)\n  delete stallData[\"type2-center\"]\n  delete stallData[\"type2-corner\"]\n  delete stallData[\"type1-center\"]\n  delete stallData[\"type1-corner\"]\n  const dataArray = Object.values(stallData)\n  const typeArray = Object.keys(stallData)\n\nconsole.log(dataArray)\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n    let j = 0\n    dataArray.forEach((ele, index) => {\n      const posArr = ele.pos\n      const colorArr = ele.color\n      const offset = rTable[typeArray[index]]\n          posArr.forEach((position, i) => {\n            dummy.position.set((position[0] + (offset.x*Math.sign(-position[2])))*34, (position[2] + (offset.y*Math.sign(-position[2])))*30, -(position[1]+offset.z))\n            const r = position[2] > 0 ? 1 : 0\n            dummy.rotation.set(0, 0, Math.PI*r)\n            dummy.updateMatrix()\n            refArr.forEach((r) => {\n              r.current.setMatrixAt(j, dummy.matrix)\n            })\n            threeColor.set(colorArr[i])\n            \n            // ref2.current.setUniformAt('diffuse', j, threeColor)\n            // ref5.current.setUniformAt('diffuse', j, threeColor)\n            j += 1\n          })\n    })\n\n    refArr.forEach((r) => {\n      r.current.instanceMatrix.needsUpdate = true\n    })\n\n  }, [data])\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh\n          ref={ref1}\n          args={[nodes.Base.geometry, null, dataArray.length]}\n          material={materials.Base_AO2} />\n        <instancedMesh\n          ref={ref2}\n          args={[nodes.Mesh003.geometry, null, dataArray.length]}\n          material={materials.Glass} />\n        <instancedMesh\n          ref={ref3}\n          args={[nodes.Mesh003_1.geometry, null, dataArray.length]}\n          material={materials.Metal_Matt} \n          color ={\"red\"}\n          />\n        <instancedMesh\n          ref={ref4}\n          args={[nodes.Mesh003_2.geometry, null, dataArray.length]}\n          material={materials.white_color_glow} />\n        <instancedMesh\n          ref={ref5}\n          args={[nodes.Mesh003_3.geometry, null, dataArray.length]}\n          material={materials.white_color} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/Broucher.0aa62824.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport model from \"../../../../Assets/Stalls/Broucher/Broucher.glb\"\n\nconst broucherData = {\n  \"type2-center\" : {\n    position : [{x : -4, y : 14, z : -5.5}, {x : 8, y : 11.5, z : -5.5}]\n  },\n  \"type3-center\" : {\n    position : [\n      {x : 1, y : 14, z : -5.5},\n      {x : 16, y : 14, z : -5.5},\n      {x : 30, y : 14, z : -5.5},\n      {x : -10, y : 10, z : -5.5},\n    ]\n  },\n  \"type2-corner\" : {\n    position : [{x : -5, y : 15, z : -5.5},{x : 8, y : 15, z : -5.5}]\n  },\n  \"type1-center\" : {\n    position : [{x : 7, y : 9, z : -5.5}]\n  },\n  \"type1-corner\" : {\n    position : [{x : 7, y : 9, z : -5.5}]\n  },\n  \"type3-corner\" : {\n    position : [\n      {x : 7, y : 14, z : -5.5},\n      {x : 20, y : 14, z : -5.5},\n      {x : -20, y : 10, z : -5.5},\n    ]\n  },\n}\n\nlet instancing = 0\nlet matrixIndex = 0\n\nexport default function Model({data, instanceSize}) {\n\n  const [loaded, setLoaded] = React.useState(false)\n\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n  const ref5 = useRef()\n  const ref6 = useRef()\n\n  const refArr = [ref1, ref2, ref3, ref4, ref5, ref6]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dataArray = Object.values(data)\n  const typeArray = Object.keys(data)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n\n  React.useLayoutEffect(() => {\n    \n\n    if(loaded === true){\n      const offsetArray = Object.values(broucherData)\n      const offsetTypeArray = Object.keys(broucherData)\n      let k = 0\n      \n      offsetArray.forEach((offData, index) => {\n        const element = offData.position\n        \n        element.forEach((ele, i) => {\n          const stall = data[offsetTypeArray[index]].pos\n          \n          stall.forEach((posi) => {\n            dummy.position.set((posi[0]+(ele.x* Math.sign(-posi[2])))*34, (posi[2]+(ele.y* Math.sign(-posi[2])))*30, -(posi[1]+ele.z)*30)\n            const r = posi[2] > 0 ? 1 : 0\n            dummy.rotation.set(0, 0, Math.PI*r)\n            dummy.updateMatrix()\n\n            refArr.forEach((r) => {\n                r.current.setMatrixAt( matrixIndex, dummy.matrix)\n            })\n            matrixIndex += 1\n          })\n\n        })\n      })\n\n      refArr.forEach((r) => {\n        r.current.instanceMatrix.needsUpdate = true\n      })\n\n\n\n    } else{\n      dataArray.forEach((d, index) => {\n        const noOfStall = d.pos.length\n        if(typeArray[index] === \"type1-center\" || typeArray[index] === \"type1-corner\"){\n          instancing += noOfStall * 1\n        } else if(typeArray[index] === \"type2-center\" || typeArray[index] === \"type2-corner\"){\n          instancing += noOfStall * 2\n        } else {\n          instancing += noOfStall * 4\n        }\n      })\n\n    }\n\n    setLoaded(true)\n\n\n  }, [loaded, data])\n\n\n  return (\n    <>\n      {loaded === true ? (\n        <group ref={group} position={[0, 1, 0]} scale={[3,3,3]} dispose={null}>\n          <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n            <instancedMesh\n              ref={ref1}\n              args ={[ nodes.Base.geometry, null, instancing]}\n              material={materials.Base_AO} />\n            <instancedMesh\n              ref={ref2}\n              args ={[ nodes.Browser.geometry, null, instancing]}\n              material={materials.Browsers_Matt} />\n            <instancedMesh\n              ref={ref3}\n              args ={[ nodes.Mesh002.geometry, null, instancing]}\n              material={materials.Metal_matt} />\n            <instancedMesh\n              ref={ref4}\n              args ={[ nodes.Mesh002_1.geometry, null, instancing]}\n              material={materials.Glass_opeq} />\n            <instancedMesh\n              ref={ref5}\n              args ={[ nodes.Mesh002_2.geometry, null, instancing]}\n              material={materials.Glass} />\n            <instancedMesh\n              ref={ref6}\n              args ={[ nodes.Mesh002_3.geometry, null, instancing]}\n              material={materials.Black_Plastic} />\n          </group>\n        </group>\n      ) : null}\n    </>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/VCTable.355cbc60.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport { extend } from '@react-three/fiber'\nimport { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\nimport model from \"../../../../Assets/Stalls/VCTable/VCTable.glb\"\n\nextend({ InstancedUniformsMesh })\n\nconst tableData = {\n  \"type2-center\" : {\n    position : [{x : -13, y : 2, z : 0}]\n  },\n  \"type3-center\" : {\n    position : [\n      {x : -10, y : -6, z : -16},\n      {x : 30, y : -6, z : -16}\n    ]\n  },\n  \"type2-corner\" : {\n    position : [{x : -14, y : 2, z : 0}]\n  },\n  \"type1-center\" : {\n    position : [{x : -9, y : 0, z : 20}]\n  },\n  \"type1-corner\" : {\n    position : [{x : -7, y : 0, z : 20}]\n  },\n  \"type3-corner\" : {\n    position : [\n      {x : -4, y : 10, z : -16},\n      {x : 18, y : -4, z : -16}\n    ]\n  },\n}\n\nlet instancing = 0\nlet matrixIndex = 0\n\nexport default function Model({data}) {\n  const [loaded, setLoaded] = React.useState(false)\n\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n\n  const refArr = [ref1, ref2, ref3, ref4]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dataArray = Object.values(data)\n  const typeArray = Object.keys(data)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n  const threeColor = React.useMemo(() => new THREE.Color(), [])\n\n  React.useLayoutEffect(() => {\n    if(loaded === true){\n      const offsetArray = Object.values(tableData)\n      const offsetTypeArray = Object.keys(tableData)\n      let k = 0\n      \n      offsetArray.forEach((offData, index) => {\n        const element = offData.position\n        \n        element.forEach((ele, i) => {\n          const stall = data[offsetTypeArray[index]].pos\n          const stallColor = data[offsetTypeArray[index]].color\n          // console.log(stallColor, stall)\n          stall.forEach((posi, ind) => {\n            dummy.position.set((posi[0]+(ele.x* Math.sign(-posi[2])))*34, (posi[2]+(ele.y* Math.sign(-posi[2])))*30, -posi[1])\n            // dummy.rotation.set(Math.PI/2, 0, 0)\n            dummy.updateMatrix()\n\n            refArr.forEach((r) => {\n                r.current.setMatrixAt( matrixIndex, dummy.matrix)\n            })\n            threeColor.set(stallColor[ind])\n        \n            ref4.current.setUniformAt('diffuse', matrixIndex, threeColor)\n            matrixIndex += 1\n          })\n\n        })\n      })\n\n      refArr.forEach((r) => {\n        r.current.instanceMatrix.needsUpdate = true\n      })\n\n\n\n    } else{\n      dataArray.forEach((d, index) => {\n        const noOfStall = d.pos.length\n        if(typeArray[index] === \"type1-center\" || typeArray[index] === \"type1-corner\"){\n          instancing += noOfStall * 1\n        } else if(typeArray[index] === \"type2-center\" || typeArray[index] === \"type2-corner\"){\n          instancing += noOfStall * 1\n        } else {\n          instancing += noOfStall * 2\n        }\n      })\n\n    }\n\n    setLoaded(true)\n\n\n  }, [loaded, data])\n\n\n\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh\n          ref={ref1}\n          args={[ nodes.Base_AO.geometry, null, instancing]}\n          material={materials.Base_AO1} />\n        <instancedMesh\n          ref={ref2}\n          args={[ nodes.Mesh.geometry, null, instancing]}\n          material={materials.white_color} />\n        <instancedMesh\n          ref={ref3}\n          args={[ nodes.Mesh_1.geometry, null, instancing]}\n          material={materials.white_color_Glow} />\n        <instancedUniformsMesh\n          ref={ref4}\n          args={[ nodes.Mesh_2.geometry, null, instancing]}\n          material={materials.Theme_color} />     \n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/KTv.9bbf4b92.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport model from \"../../../../Assets/Stalls/KTv/KTv.glb\"\n\nconst tvData = {\n  \"type2-center\" : {\n    position : [{x : 15, y : 4, z : -16, r: Math.PI/2}]\n  },\n  \"type3-center\" : {\n    position : [\n      {x : -10, y : 4, z : -16, r: -Math.PI/2},\n      {x : 30, y : 4, z : -16, r : Math.PI/2}\n    ]\n  },\n  \"type2-corner\" : {\n    position : [{x : -5, y : -11, z : 0, r: 0}]\n  },\n  \"type1-center\" : {\n    position : [{x : 10, y : 0, z : 20, r: Math.PI/2}]\n  },\n  \"type1-corner\" : {\n    position : [{x : 12, y : 0, z : 20, r: Math.PI/2}]\n  },\n  \"type3-corner\" : {\n    position : [\n      {x : -22, y : -3, z : -16, r: -Math.PI/2},\n      {x : 18, y : -12, z : -16, r: Math.PI/2},\n    ]\n  },\n}\n\nlet instancing = 0\nlet matrixIndex = 0\n\nexport default function Model({data}) {\n  const [loaded, setLoaded] = React.useState(false)\n\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n  const ref4 = useRef()\n\n  const refArr = [ref1, ref2, ref3, ref4]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dataArray = Object.values(data)\n  const typeArray = Object.keys(data)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n\n  React.useLayoutEffect(() => {\n    \n\n    if(loaded === true){\n      const offsetArray = Object.values(tvData)\n      const offsetTypeArray = Object.keys(tvData)\n      let k = 0\n      \n      offsetArray.forEach((offData, index) => {\n        const element = offData.position\n        \n        element.forEach((ele, i) => {\n          const stall = data[offsetTypeArray[index]].pos\n          \n          stall.forEach((posi) => {\n            dummy.position.set((posi[0]+(ele.x* Math.sign(-posi[2])))*34, (posi[2]+(ele.y* Math.sign(-posi[2])))*30, -posi[1])\n            const R = ele.r > Math.PI/2 ? 1 : 0\n\n            dummy.rotation.set(0, 0, ele.r* Math.sign(posi[2]) + Math.PI/2 * R)\n            dummy.updateMatrix()\n\n            refArr.forEach((r) => {\n                r.current.setMatrixAt( matrixIndex, dummy.matrix)\n            })\n            matrixIndex += 1\n          })\n\n        })\n      })\n\n      refArr.forEach((r) => {\n        r.current.instanceMatrix.needsUpdate = true\n      })\n\n\n\n    } else{\n      dataArray.forEach((d, index) => {\n        const noOfStall = d.pos.length\n        if(typeArray[index] === \"type1-center\" || typeArray[index] === \"type1-corner\"){\n          instancing += noOfStall * 1\n        } else if(typeArray[index] === \"type2-center\" || typeArray[index] === \"type2-corner\"){\n          instancing += noOfStall * 1\n        } else {\n          instancing += noOfStall * 2\n        }\n      })\n\n    }\n\n    setLoaded(true)\n\n\n  }, [loaded, data, tvData])\n\n  return (\n    <group ref={group} scale={[3,3,3]} dispose={null}>\n      <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n        <instancedMesh \n          ref={ref1}\n          args={[ nodes.Base.geometry, null, instancing]}\n          material={materials.Base_AO} />\n        <instancedMesh \n          ref={ref2}\n          args={[ nodes.Mesh001.geometry, null, instancing]}\n          material={materials.frame_color} />\n        <instancedMesh \n          ref={ref3}\n          args={[ nodes.Mesh001_1.geometry, null, instancing]}\n          material={materials.body_paint_matt} />\n        <instancedMesh \n          ref={ref4}\n          args={[ nodes.Mesh001_2.geometry, null, instancing]}\n          material={materials.Display} />\n      </group>\n    </group>\n  )\n}\n\nuseGLTF.preload(model)\n","export default __webpack_public_path__ + \"static/media/Display.e82bb76c.glb\";","import React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport model from \"../../../../Assets/Stalls/Display/Display.glb\"\n\nconst displayData = {\n  \"type2-center\" : {\n    position : [{x : 1, y : -15, z : 1}]\n  },\n  \"type3-center\" : {\n    position : [\n      {x : 6, y : -23, z : 1},\n      {x : 12, y : -23, z : 1}\n    ]\n  },\n  \"type2-corner\" : {\n    position : [{x : 5, y : -11.5, z : 0}]\n  },\n  \"type1-center\" : {\n    position : [{x : 0, y : -8, z : 1}]\n  },\n  \"type1-corner\" : {\n    position : [{x : 0, y : -8, z : 1}]\n  },\n  \"type3-corner\" : {\n    position : [\n      {x :-2, y : -22.5, z : 1},\n      {x :5, y : -22, z : 1},\n    ]\n  },\n}\n\nlet instancing = 0\nlet matrixIndex = 0\n\nexport default function Model({data}) {\n  const [loaded, setLoaded] = React.useState(false)\n\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n\n  const refArr = [ref1, ref2, ref3]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dataArray = Object.values(data)\n  const typeArray = Object.keys(data)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n\n  React.useLayoutEffect(() => {\n    \n\n    if(loaded === true){\n      const offsetArray = Object.values(displayData)\n      const offsetTypeArray = Object.keys(displayData)\n      let k = 0\n      \n      offsetArray.forEach((offData, index) => {\n        const element = offData.position\n        \n        element.forEach((ele, i) => {\n          const stall = data[offsetTypeArray[index]].pos\n          \n          stall.forEach((posi) => {\n            dummy.position.set((posi[0]+(ele.x* Math.sign(-posi[2])))*68, (posi[2]+(ele.y* Math.sign(-posi[2])))*60, -(posi[1]+ele.z)*60)\n            const r = posi[2] < 0 ? 0 : 1\n            dummy.rotation.set(0, 0, Math.PI*r)\n            dummy.updateMatrix()\n\n\n            refArr.forEach((r) => {\n                r.current.setMatrixAt( matrixIndex, dummy.matrix)\n            })\n            matrixIndex += 1\n          })\n\n        })\n      })\n\n      refArr.forEach((r) => {\n        r.current.instanceMatrix.needsUpdate = true\n      })\n\n\n\n    } else{\n      dataArray.forEach((d, index) => {\n        const noOfStall = d.pos.length\n        if(typeArray[index] === \"type1-center\" || typeArray[index] === \"type1-corner\"){\n          instancing += noOfStall * 1\n        } else if(typeArray[index] === \"type2-center\" || typeArray[index] === \"type2-corner\"){\n          instancing += noOfStall * 1\n        } else {\n          instancing += noOfStall * 2\n        }\n      })\n\n    }\n\n    setLoaded(true)\n\n\n  }, [loaded, data])\n\n  \n  return (\n    <>\n      {loaded === true ? (\n        <group ref={group} scale={[3,3,3]} dispose={null}>\n          <group rotation={[Math.PI / 2, 0, 0]} scale={[0.005, 0.005, 0.005]}>\n            {/* <group scale={[0.5, 0.5, 0.5]}> */}\n            <instancedMesh \n              ref={ref1}\n              args={[ nodes.Base_AO.geometry, null, instancing]}\n              material={materials.base_AO} />\n            <instancedMesh \n              ref={ref2}\n              args={[ nodes.Mesh.geometry, null, instancing]}\n              material={materials.Plastic} />\n            <instancedMesh \n              ref={ref3}\n              args={[ nodes.Mesh_1.geometry, null, instancing]}\n              material={materials.Display} />\n            {/* </group> */}\n          </group>\n        </group>\n      ) : null}\n    </>\n  )\n}\n\nuseGLTF.preload(model)\n","import { useTexture } from \"@react-three/drei\";\r\nimport React, { useRef } from \"react\";\r\nimport * as THREE from \"three\";\r\n\r\n// {l : true, x : -13.15, y: -2, r : Math.PI, z: -23},\r\n\r\nlet scalar = 1;\r\n\r\nconst noOfTex = {\r\n  \"type1-center\": 2,\r\n  \"type1-corner\": 2,\r\n  \"type2-center\": 4,\r\n  \"type2-corner\": 4,\r\n  \"type3-center\": 6,\r\n  \"type3-corner\": 5\r\n};\r\n\r\nconst size = {\r\n  \"type1-center\": 0.5,\r\n  \"type1-corner\": 0.5,\r\n  \"type2-center\": 0.6,\r\n  \"type2-corner\": 0.6,\r\n  \"type3-center\": 0.6,\r\n  \"type3-corner\": 0.6\r\n};\r\n\r\nconst noOfLogo = {\r\n  \"type1-center\": 2,\r\n  \"type1-corner\": 2,\r\n  \"type2-center\": 2,\r\n  \"type2-corner\": 2,\r\n  \"type3-center\": 2,\r\n  \"type3-corner\": 2\r\n};\r\n\r\nconst bannerPositions = {\r\n  \"type1-center\": [\r\n    { l: true, x: 0, y: 8.8, r: Math.PI, z: -3.5 },\r\n    { l: false, x: 7, y: 2, r: Math.PI, z: 9 },\r\n    { l: false, x: -7, y: 2, r: Math.PI, z: 9 }\r\n  ],\r\n  \"type1-corner\": [\r\n    { l: true, x: 3, y: 9, r: Math.PI, z: 0.1 },\r\n    { l: false, x: -7, y: 2, r: Math.PI, z: 9.5 },\r\n    { l: false, x: -12.5, y: 2, r: Math.PI / 2, z: 3 }\r\n  ],\r\n\r\n  \"type2-center\": [\r\n    { l: true, x: -5, y: 9, r: Math.PI, z: -11.5 },\r\n    { l: true, x: -5, y: 9, r: Math.PI, z: -11.5 },\r\n    { l: false, x: -12, y: 2, r: Math.PI, z: 15 },\r\n    { l: false, x: 9, y: 2, r: Math.PI, z: 15 },\r\n    { l: false, x: 14.15, y: 2, r: -Math.PI / 2, z: 9.5 },\r\n    { l: false, x: -17, y: 2, r: Math.PI / 2, z: 9.5 }\r\n  ],\r\n\r\n  \"type2-corner\": [\r\n    { l: true, x: 8, y: 8, r: Math.PI, z: 11.95 },\r\n    { l: false, x: 2, y: 2, r: Math.PI, z: 11.95 },\r\n    { l: false, x: -12, y: 2, r: Math.PI, z: 11.95 },\r\n    { l: false, x: -14.5, y: 2, r: Math.PI / 2, z: 6 },\r\n    { l: false, x: -14.5, y: 2, r: Math.PI / 2, z: -5 }\r\n  ],\r\n\r\n  \"type3-corner\": [\r\n    { l: true, x: 4, y: 10, r: Math.PI, z: -15.3 },\r\n    { l: false, x: 17, y: 2, r: Math.PI, z: 22.85 },\r\n    { l: false, x: 9, y: 2, r: Math.PI, z: 22.85 },\r\n    { l: false, x: 22, y: 2, r: -Math.PI / 2, z: -4 },\r\n    { l: false, x: 22, y: 2, r: Math.PI / 2, z: 9 },\r\n    { l: false, x: -12, y: 2, r: Math.PI, z: 22.85 }\r\n  ],\r\n  \"type3-center\": [\r\n    { l: true, x: -9.45, y: 8.5, r: Math.PI, z: -11.5 },\r\n    { l: false, x: 8.5, y: 2, r: Math.PI, z: 23.5 },\r\n    { l: false, x: 1, y: 2, r: Math.PI, z: 23.5 },\r\n    { l: false, x: -18.5, y: 2, r: Math.PI, z: 23.5 },\r\n    { l: false, x: -26, y: 2, r: Math.PI, z: 23.5 },\r\n    { l: false, x: 13.2, y: 2, r: -Math.PI / 2, z: 15 },\r\n    { l: false, x: -31.2, y: 2, r: Math.PI / 2, z: 15 }\r\n  ]\r\n};\r\n\r\nconst BannerInstance = ({ data }) => {\r\n  const instancingSize =\r\n    noOfLogo[data[0]] + data[3].slice(0, noOfTex[data[0]]).length;\r\n  const ref = useRef();\r\n  const images = [];\r\n  data[3].map((img, index) => {\r\n    images.push(img.image_url);\r\n  });\r\n\r\n  const imageTextures = useTexture([data[2], ...images.slice(0, 6)]);\r\n  const dummy = React.useMemo(() => new THREE.Object3D(), []);\r\n  React.useLayoutEffect(() => {\r\n    const stallGlobalPos = data[1];\r\n    const local = bannerPositions[data[0]];\r\n    const instanceAttrib = [];\r\n    let instanceIndex = 0;\r\n\r\n    Array(instancingSize)\r\n      .fill(null)\r\n      .map((inst, index) => {\r\n        const localPos = local[index];\r\n\r\n        if (localPos) {\r\n          if (localPos.l === true) {\r\n            scalar = size[data[0]];\r\n            instanceIndex = 0;\r\n            instanceAttrib.push(instanceIndex);\r\n          } else {\r\n            scalar = 1;\r\n            instanceIndex += 1;\r\n            instanceAttrib.push(instanceIndex);\r\n          }\r\n          dummy.position.set(\r\n            (stallGlobalPos[0] + localPos.x * Math.sign(stallGlobalPos[2])) *\r\n              34,\r\n            (stallGlobalPos[2] + localPos.z * Math.sign(stallGlobalPos[2])) *\r\n              30,\r\n            -(stallGlobalPos[1] + localPos.y) * 30\r\n          );\r\n          if (localPos.r === Math.PI) {\r\n            const r = stallGlobalPos[2] > 0 ? 1 : 0;\r\n            dummy.rotation.set(-Math.PI / 2, localPos.r * r, 0);\r\n          } else {\r\n            dummy.rotation.set(-Math.PI / 2, localPos.r, 0);\r\n          }\r\n          dummy.scale.set(scalar, scalar, scalar);\r\n          dummy.updateMatrix();\r\n          ref.current.setMatrixAt(index, dummy.matrix);\r\n        }\r\n      });\r\n\r\n    ref.current.instanceMatrix.needsUpdate = true;\r\n\r\n    ref.current.geometry.addAttribute(\r\n      \"textureIndex\",\r\n      new THREE.InstancedBufferAttribute(\r\n        new Float32Array([...instanceAttrib]),\r\n        1\r\n      )\r\n    );\r\n    ref.current.material.onBeforeCompile = function (shader) {\r\n      shader.uniforms.textures = { type: \"tv\", value: [...imageTextures] };\r\n      shader.vertexShader = shader.vertexShader\r\n        .replace(\r\n          \"#define STANDARD\",\r\n          `#define STANDARD\r\n                  varying float vTextureIndex;`\r\n        )\r\n        .replace(\r\n          \"#include <common>\",\r\n          `#include <common>\r\n              attribute float textureIndex;`\r\n        )\r\n        .replace(\r\n          \"#include <project_vertex>\",\r\n          `#include <project_vertex>\r\n              vTextureIndex=textureIndex;`\r\n        );\r\n\r\n      const a = function () {\r\n        // let string = [];\r\n        // // const string2 = []\r\n\r\n        // for (let index = 0; index < imageTextures.length; index++) {\r\n        //     string.push(`col += texture2D(textures[${index}], vUv ) * step(${-0.1+index}, x) * step(x, ${0.1+index});`)\r\n        // }\r\n\r\n        return `#include <fog_fragment>\r\n            float x = vTextureIndex;\r\n            vec4 col = vec4(0, 0, 0, 0);\r\n            col += texture2D(textures[0], vUv ) * step(-0.1, x) * step(x, 0.1);\r\n            col += texture2D(textures[1], vUv ) * step(0.9, x) * step(x, 1.1);\r\n            col += texture2D(textures[2], vUv ) * step(1.9, x) * step(x, 2.1);\r\n            col += texture2D(textures[3], vUv ) * step(2.9, x) * step(x, 3.1);\r\n            col += texture2D(textures[4], vUv ) * step(3.1, x) * step(x, 4.1);\r\n            col += texture2D(textures[5], vUv ) * step(4.9, x) * step(x, 5.1);\r\n            col += texture2D(textures[6], vUv ) * step(5.9, x) * step(x, 6.1);\r\n            col += texture2D(textures[7], vUv ) * step(6.9, x) * step(x, 7.1);\r\n            col += texture2D(textures[8], vUv ) * step(7.9, x) * step(x, 8.1);\r\n            col += texture2D(textures[9], vUv ) * step(8.9, x) * step(x, 9.1);\r\n            col += texture2D(textures[10], vUv ) * step(9.9, x) * step(x, 10.1);\r\n            col += texture2D(textures[11], vUv ) * step(10.9, x) * step(x, 11.1);\r\n            gl_FragColor = col;\r\n            `;\r\n      };\r\n      shader.fragmentShader = shader.fragmentShader\r\n        .replace(\r\n          \"#define STANDARD\",\r\n          `#define STANDARD\r\n                  uniform sampler2D textures[${15}];\r\n                  varying float vTextureIndex;`\r\n        )\r\n        .replace(\"#include <fog_fragment>\", a());\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <group scale={[3, 3, 3]} dispose={null}>\r\n        <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\r\n          <instancedMesh ref={ref} args={[null, null, instancingSize]}>\r\n            <planeBufferGeometry args={[6 * 1.33 * 30, 6 * 30]}>\r\n              <instancedBufferAttribute\r\n                attachObject={[\"attributes\", \"textureIndex\"]}\r\n                args={[new Float32Array([...Array(instancingSize).keys()]), 1]}\r\n              />\r\n            </planeBufferGeometry>\r\n            <meshStandardMaterial\r\n              transparent=\"true\"\r\n              map={imageTextures[imageTextures.length - 1]}\r\n              side={THREE.DoubleSide}\r\n            />\r\n          </instancedMesh>\r\n        </group>\r\n      </group>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default BannerInstance;\r\n","export default __webpack_public_path__ + \"static/media/Standee.0f9108cc.glb\";","import React, { useRef } from 'react'\nimport { useGLTF, useTexture } from '@react-three/drei'\nimport * as THREE from \"three\"\nimport model from \"../../../../Assets/Stalls/Standee/Standee.glb\"\n\nconst broucherData = {\n  \"type2-center\" : {\n    position : [{x : 15, y : 20, z : -5.1, r : -Math.PI/6}]\n  },\n  \"type3-center\" : {\n    position : [\n      {x : -10, y : 23, z : -5.1, r : Math.PI/6},\n      {x : 30, y : 23, z : -5.1, r : -Math.PI/6}\n    ]\n  },\n  \"type2-corner\" : {\n    position : [{x : -20, y : 15, z : -5.1, r : Math.PI/6}]\n  },\n  \"type3-corner\" : {\n    position : [\n      {x : -18, y : 23, z : -5.1, r : Math.PI/6},\n      {x : 20, y : 23, z : -5.1, r : -Math.PI/6},\n    ]\n  },\n}\n\nlet instancing = 0\nlet matrixIndex = 0\n\nexport default function Model({data}) {\n  \n  const [loaded, setLoaded] = React.useState(false)\n  const group = useRef()\n  const ref1 = useRef()\n  const ref2 = useRef()\n  const ref3 = useRef()\n\n  const images = []\n\n  const typesArray = Object.keys(broucherData)\n  typesArray.map((type, index) => {\n    data[type].banner.map((img, i) => {\n      img.map((im, j) => {\n        if(im.banner_placement_id === \"SL1\" || im.banner_placement_id === \"SL2\"){\n          images.push(im.image_url)\n        }\n      })\n    })\n  })\n\n  const standeeTex = useTexture([...images])\n\n  const refArr = [ref1, ref2, ref3]\n\n  const { nodes, materials } = useGLTF(model)\n\n  const dataArray = Object.values(data)\n  const typeArray = Object.keys(data)\n\n  const dummy = React.useMemo(() => new THREE.Object3D(), [])\n\n  React.useLayoutEffect(() => {\n    \n\n    if(loaded === true){\n      const offsetArray = Object.values(broucherData)\n      const offsetTypeArray = Object.keys(broucherData)\n      let k = 0\n      \n      offsetArray.forEach((offData, index) => {\n        const element = offData.position\n        \n        element.forEach((ele, i) => {\n          const stall = data[offsetTypeArray[index]].pos\n          \n          \n          stall.forEach((posi) => {\n            dummy.position.set((posi[0]+(ele.x* Math.sign(-posi[2])))*34, (posi[2]+(ele.y* Math.sign(-posi[2])))*30, -(posi[1]+ele.z)*30)\n            const r = posi[2] > 0 ? 1 : 0\n            dummy.rotation.set(0, 0, Math.PI*r - ele.r)\n            dummy.updateMatrix()\n\n            refArr.forEach((r) => {\n                r.current.setMatrixAt( matrixIndex, dummy.matrix)\n            })\n            matrixIndex += 1\n          })\n\n        })\n      })\n\n      refArr.forEach((r) => {\n        r.current.instanceMatrix.needsUpdate = true\n      })\n\n\n\n    } else{\n      dataArray.forEach((d, index) => {\n        const noOfStall = d.pos.length\n        if(typeArray[index] === \"type1-center\" || typeArray[index] === \"type1-corner\"){\n          instancing += noOfStall * 0\n        } else if(typeArray[index] === \"type2-center\" || typeArray[index] === \"type2-corner\"){\n          instancing += noOfStall * 1\n        } else {\n          instancing += noOfStall * 2\n        }\n      })\n\n    }\n\n    setLoaded(true)\n\n\n  }, [loaded, data])\n\n  return (\n    <>\n      {loaded === true ? (\n        <group ref={group} scale={[3,3,3]} dispose={null}>\n          <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>\n            <instancedMesh\n              ref={ref1}\n              args={[nodes.Base_AO.geometry, null, instancing]}\n              material={materials.base_AO} />\n            <instancedMesh\n              ref={ref2}\n              args={[nodes.Mesh.geometry, null, instancing]}\n              material={materials.Standee_Texture_1} />\n            <instancedMesh\n              ref={ref3}\n              args={[nodes.Mesh_1.geometry, null, instancing]}\n              material={materials.Metal_matt} />\n          </group>\n        </group>\n      ) : null}\n    </>\n  )\n}\n\nuseGLTF.preload(model)\n","import \"./styles.css\";\n\nimport { useEffect, useState, Suspense } from \"react\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { OrbitControls, Stats } from \"@react-three/drei\";\nimport { Physics } from \"@react-three/cannon\";\n\n//Components\nimport HtmlOverlay from \"./Components/HtmlOverlay/HtmlOverlay\";\nimport Firstpersonprespective from \"./Components/Player/Firstpersonprespective\";\nimport Lights from \"./Components/Lights/Lights\";\nimport StallPlacement from \"./Components/Hall/Stalls/StallPlacement\";\nimport { Loader } from \"./Components/Loader/Loader\";\n\nfunction App() {\n  const [stallData, setStallData] = useState([]);\n  const [types, setTypes] = useState([]);\n\n  const getStallData = async () => {\n    const response = await fetch(\n      \"https://boring-goldberg-0ae08e.netlify.app/Json_VishramTest.json\"\n    );\n    const data = await response.json();\n    setStallData(data.data.stall);\n  };\n\n  useEffect(() => {\n    getStallData();\n  }, []);\n\n  useEffect(() => {\n    const rows = [];\n    stallData.forEach((stall, index) => {\n      if (stallData.length % 2 === 0) {\n        if (index % 2 === 0) {\n          const coloumn = [stall.stall_type, stallData[index + 1].stall_type];\n          rows.push(coloumn);\n        }\n      } else {\n        if (index === stallData.length - 1) {\n          if (index % 2 === 0) {\n            const coloumn = [stall.stall_type, \"null\"];\n            rows.push(coloumn);\n          }\n        } else {\n          if (index % 2 === 0) {\n            const coloumn = [stall.stall_type, stallData[index + 1].stall_type];\n            rows.push(coloumn);\n          }\n        }\n      }\n    });\n    setTypes(rows);\n  }, [stallData]);\n\n  useEffect(() => {}, [types]);\n\n  return (\n    <>\n      {types.length > 0 ? (\n        <>\n          <Canvas\n            shadows\n            gl={{ alpha: false, antialias: true }}\n            camera={{\n              fov: 45,\n              position: [-400, 20, -50],\n              near: 0.1,\n              far: 2000\n            }}\n            onCreated={({ gl }) => {\n              gl.physicallyCorrectLights = true;\n              gl.outputEncoding = true;\n            }}\n            dpr={Math.min(2, window.devicePixelRatio)}\n          >\n            <Lights />\n            {/* <axesHelper position = {[0, 30, 0]} scale = {[30,30,30]}/> */}\n\n            {/* <Physics gravity={[0, 10, 0]}>\n              <Suspense fallback={null}>\n                <StallPlacement stallData={stallData} types={types} />\n              </Suspense>\n              <Firstpersonprespective />\n            </Physics> */}\n\n            <mesh>\n              <boxBufferGeometry />\n              <meshBasicMaterial />\n            </mesh>\n\n            <OrbitControls />\n          </Canvas>\n          <HtmlOverlay />\n          <Stats />\n        </>\n      ) : (\n        <h1>Loading</h1>\n      )}\n    </>\n  );\n}\n\nexport default App;\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n"],"sourceRoot":""}